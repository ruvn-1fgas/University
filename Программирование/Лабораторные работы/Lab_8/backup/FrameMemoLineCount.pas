/// <summary>
/// A Frame to display a TMemo with linenumbers and a selection rectangle
/// </summary>
/// <remarks>
/// The line numbers are only displayed, when wordwrap is false
/// <img src="FrameMemoLineCount.jpg">
/// Documentation generated by <a href="https://www.hastasoft.de/PPME.htm">Pascal Project Manager &amp; Editor</a>
///
/// How to use:
///     1 Add the unit to your project
///     2 From the Component-selector select frames and draw a ectangle on
///       the form, were the frame sould be insert
///     3 In the opened dialog select FrameMemoLineCount
///    
///     Downloadlink for source: <a href="https://www.devpage.de/FrameMemoLineCount.zip">FrameMemoLineCount.zip</a>
/// </remarks>
unit FrameMem;

//{$MODE Delphi}

interface

uses
  SysUtils,
  Types,
  UITypes,
  Classes,
  Variants,
  Graphics,
  Controls,
  Forms,
  Objects,
  Memo,
  Layouts,
  ListBox,
  ScrollBox,
  Memo.Types;

type
  /// <summary>
  /// This is the frame with the memo
  /// </summary>
  TFrameMemoLineCount = class(TFrame)
    LayLinecountMemo: TLayout;
    /// <summary>
    /// Use this to Access the Memo, e.g. for loading and saving text
    /// </summary>
    mTxt: TMemo;
    ColorLine: TRectangle;
    mLines: TMemo;
    Rectangle1: TRectangle;
    cbShowLines: TCheckBox;
    lbRow: TLabel;
    lbCol: TLabel;
    lbChar: TLabel;

    procedure mTxtChangeTracking(Sender: TObject);
    procedure mTxtPainting(Sender: TObject; Canvas: TCanvas;  const ARect: TRectF);
    procedure mTxtViewportPositionChange(Sender: TObject;  const OldViewportPosition, NewViewportPosition: TPointF; const ContentSizeChanged: Boolean);
    procedure Timer1Timer(Sender: TObject);
    procedure cbShowLinesChange(Sender: TObject);
    procedure mTxtKeyUp(Sender: TObject; var Key: Word; var KeyChar: Char; Shift: TShiftState);
  private
    { Private-Deklarationen }
    /// <summary>
    /// Display the current row and col position in editor
    /// </summary>
    iRow, iCol: Integer;
    AChar: Char;
  public
    { Public-Deklarationen }
    MyTimer: TTimer;
  end;

implementation

{$R *.fmx}

procedure TFrameMemoLineCount.cbShowLinesChange(Sender: TObject);
begin
  mTxt.WordWrap := cbShowLines.IsChecked;
  mLines.Visible := not cbShowLines.IsChecked;
end;

procedure TFrameMemoLineCount.mTxtChangeTracking(Sender: TObject);
var
  c, L: Integer;
begin
  if MyTimer = NIL then begin
    MyTimer := TTimer.Create(self);
    myTimer.Interval := 500;
    myTimer.OnTimer := Timer1Timer;
    MyTimer.Enabled := True;
  end;

  //mLines.Lines.BeginUpdate;
  try

    if mLines.Lines.Count < mTxt.Lines.Count then begin
      c := mLines.Lines.Count;
      for L := c+1 to mTxt.Lines.Count do begin
        mLines.Lines.Add(' ' + L.ToString);
      end;
      exit;
    end;

    if mLines.Lines.Count > mTxt.Lines.Count then begin
      c := mLines.Lines.Count-1;
      for L := c downto mTxt.Lines.Count do begin
        mLines.Lines.delete (L);
      end;
      exit;
    end;

  finally
    //mLines.Lines.EndUpdate; { Cant use that: resets MemoLines ViewportPosition and will have flickering}
  end;
end;

procedure TFrameMemoLineCount.mTxtKeyUp(Sender: TObject; var Key: Word; var KeyChar: Char; Shift: TShiftState);
begin
  if Key = vkReturn then begin
    mLines.ViewportPosition := MTxt.ViewportPosition;
  end;
end;

procedure TFrameMemoLineCount.mTxtPainting(Sender: TObject; Canvas: TCanvas; const ARect: TRectF);
begin
  if (ColorLine.Position.Y <> TMemo(Sender).Caret.Pos.Y) then
  begin
    ColorLine.Position.Y := TMemo (Sender).Caret.Pos.Y;
  end;
end;

procedure TFrameMemoLineCount.mTxtViewportPositionChange(Sender: TObject;  const OldViewportPosition, NewViewportPosition: TPointF;
  const ContentSizeChanged: Boolean);
begin
  mLines.ViewportPosition := NewViewportPosition;

  if mTxt.HScrollBar.Visible then begin
    mLines.Margins.Bottom := mTxt.HScrollBar.height+1;
  end else begin
    mLines.Margins.Bottom := 0;
  end;
end;

procedure TFrameMemoLineCount.Timer1Timer(Sender: TObject);
var
  S: String;
begin
  if visible = false then exit;

  if iRow <> mTxt.CaretPosition.Line+1 then begin
    iRow := mTxt.CaretPosition.Line+1;
    lbRow.Text := 'Ze ' + iRow.ToString;
  end;

  if iCol <> mTxt.CaretPosition.Pos+1 then begin
    iCol := mTxt.CaretPosition.pos+1;
    lbCol.Text := 'Sp ' + iCol.ToString;
  end;

  S := mTxt.Lines[mTxt.CaretPosition.Line];
  S := copy (S, mTxt.CaretPosition.Pos+1, 1);

  if S <> '' then begin
    if AChar <> S[1] then begin
      AChar := S[1];
      lbChar.Text := ' ch ' + Ord(S[1]).ToString;
    end;
  end else begin
    lbChar.Text := '';
  end;
end;

end.
